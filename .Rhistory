rm(active_idents)
# Calculate average/percent expression for each gene, by "split.by" if
# provided.
exp_avg <- lr_data %>%
group_by(active_idents, .add = TRUE)
exp_pct <- lr_data %>%
group_by(active_idents, .add = TRUE)
if (!is.null(split.by)) {
split.by_name <- as.name(split.by)
exp_avg <- exp_avg %>%
group_by(!!split.by_name, .add = TRUE)
exp_pct <- exp_pct %>%
group_by(!!split.by_name, .add = TRUE)
}
exp_avg <- exp_avg %>%
summarise(
across(.cols = where(is.numeric),
.fns = mean
)
)
exp_pct <- exp_pct %>%
summarise(
across(.cols = where(is.numeric),
.fns = function(x) round(mean(x > 0), 3)
)
)
# Determine which genes meet minimum percent detection threshold
minpct_genes <- sapply(
X = exp_pct[sapply(exp_pct, is.numeric)],
FUN = function(x) any(x > min.pct)
)
minpct_genes <- names(which(minpct_genes))
ligand_detected <- ligand_genes %in% minpct_genes
receptor_detected <- receptor_genes %in% minpct_genes
ligand_genes <- ligand_genes[ligand_detected & receptor_detected]
receptor_genes <- receptor_genes[ligand_detected & receptor_detected]
lr_ref <- lr_ref[ligand_detected & receptor_detected,]
rm(minpct_genes)
# Generate all possible combinations of cell-type pairs (and split.by). Create
# columns with cell-type counts for permutation test sampling.
if (!is.null(split.by)) {
var_set <- expand.grid(unique(lr_data[['active_idents']]),
unique(lr_data[['active_idents']]),
unique(lr_data[[split.by]]),
stringsAsFactors = FALSE)
colnames(var_set) <- c('Ligand_cell', 'Receptor_cell', 'split.by')
cell_counts <- table(
slot(object = seurat.object, name = 'active.ident'),
slot(object = seurat.object, name = 'meta.data')[[split.by]]
)
} else {
var_set <- expand.grid(unique(lr_data[['active_idents']]),
unique(lr_data[['active_idents']]),
stringsAsFactors = FALSE)
colnames(var_set) <- c('Ligand_cell', 'Receptor_cell')
cell_counts <- table(slot(object = seurat.object, name = 'active.ident'))
}
var_set$Ligand_cell_count <- NA
var_set$Receptor_cell_count <- NA
for (i in 1:nrow(var_set)) {
tmp_row_lig <- which(rownames(cell_counts) == var_set$Ligand_cell[i])
tmp_row_rec <- which(rownames(cell_counts) == var_set$Receptor_cell[i])
tmp_col <- which(colnames(cell_counts) == var_set$split.by[i])
var_set$Ligand_cell_count[i] <- cell_counts[tmp_row_lig, tmp_col]
var_set$Receptor_cell_count[i] <- cell_counts[tmp_row_rec, tmp_col]
}
rm(tmp_row_lig, tmp_row_rec, tmp_col)
# Calculate LR scores (for data, not nulls). Convert to list to vectorize.
index_x <- var_set[['Ligand_cell']]
index_y <- var_set[['Receptor_cell']]
exp_names <- exp_avg[['active_idents']]
if (!is.null(split.by)) {
index_x <- paste(index_x, var_set[['split.by']], sep = '_')
index_y <- paste(index_y, var_set[['split.by']], sep = '_')
exp_names <- paste(exp_names, exp_avg[[split.by]], sep = '_')
}
index_x <- match(x = index_x, table = exp_names)
index_y <- match(x = index_y, table = exp_names)
index_l <- match(ligand_genes, colnames(exp_avg))
index_r <- match(receptor_genes, colnames(exp_avg))
exp_avg_lig <- as.matrix(exp_avg[index_x, index_l])
exp_avg_rec <- as.matrix(exp_avg[index_y, index_r])
exp_scores <- 1/2 * (exp_avg_lig + exp_avg_rec)
exp_scores <- split(
x = exp_scores,
f = rep(1:nrow(exp_scores), each = ncol(exp_scores))
)
names(exp_scores) <- apply(
X = var_set,
MARGIN = 1,
FUN = function(x) {
if (!is.null(split.by)) {
paste(x[c('Ligand_cell','Receptor_cell','split.by')], collapse = '_')
} else {
paste(x[c('Ligand_cell','Receptor_cell')], collapse = '_')
}
}
)
exp_scores <- lapply(
X = exp_scores,
FUN = function(x) {
names(x) <- paste(colnames(exp_avg_lig),
colnames(exp_avg_rec),
sep = '_')
return(x)
}
)
class(exp_scores)
# Extract individual matrices for ligand/receptor gene expression values to be
# used for random sampling of cells (via matrix multiplication). Reformat the
# lr_data data.frame to data.table before setting matrix to allow duplicated
# column names (gene names)
lr_data_ligands <- as.matrix(as.data.table(lr_data)[, ..ligand_genes])
lr_data_receptors <- as.matrix(as.data.table(lr_data)[, ..receptor_genes])
Get_Pvals <- function(
nulls,
score
) {
pval <- 1 - (ecdf(nulls)(score))
return(pval)
}
cell_sample <- function(
sample.count,
total.count
) {
tmp <- rep(FALSE, times = total.count)
tmp[sample(x = total.count, size = sample.count, replace = FALSE)] <- TRUE
return(tmp)
}
cell_counts
sapply(X = cell_counts, FUN = `[`, 'VSMC', 'Uninjured')
sapply(X = cell_counts, FUN = `[[`, 'VSMC', 'Uninjured')
cell_counts['VSMC','Uninjured']
sapply(X = cell_counts, FUN = `[`, 'VSMC', 'Uninjured')
sapply(X = cell_counts, FUN = `[`, 'VSMC')
sapply(X = cell_counts, FUN = `[`, '1')
sapply(X = cell_counts, FUN = `[`)
apply(X = cell_counts, FUN = `[`)
?mapply
library(BiocParallel)
rm(list = ls())
gc()
dev.off()
source('D:/SingleCellTools/R/StandardLR2.R', echo=TRUE)
vascular <- readRDS(file = '../MiamiProject/sci_scRNAseq/data/vascular.rds')
vascular$vascular_subcluster <- gsub(
pattern = ' ',
replacement = '-',
x = vascular$vascular_subcluster
)
Idents(vascular) <- 'vascular_subcluster'
ref <- read.csv(file = '../MiamiProject/sci_scRNAseq/ref/fantom_PairsLigRec_mouse.csv')
ref <- ref[1:50,]
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
source('D:/SingleCellTools/R/StandardLR2.R', echo=TRUE)
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
gc()
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
t3
seurat.object = vascular
ref.path = NULL
vascular$vascular_subcluster <- gsub(
pattern = ' ',
replacement = '-',
x = vascular$vascular_subcluster
)
Idents(vascular) <- 'vascular_subcluster'
ref <- read.csv(file = '../MiamiProject/sci_scRNAseq/ref/fantom_PairsLigRec_mouse.csv')
ref <- ref[1:50,]
ref.path = NULL
split.by = 'time'
min.pct = 0.1
assay = "RNA"
slot = "counts"
resample = 1000
adjust.pval = FALSE
lr.ref <- ref
lr.ref = read.csv(file = '../MiamiProject/sci_scRNAseq/ref/fantom_PairsLigRec_mouse.csv')[1:50,]
split.by = 'time'
min.pct = 0.1
assay = "RNA"
slot = "counts"
resample = 1000
adjust.pval = FALSE
# 'seurat.object' input check
if (class(seurat.object) != 'Seurat') {
stop('\"seurat.object\" must be of class Seurat.')
}
# Check that provided assay is in seurat.object.
if (!(assay %in% names(slot(object = seurat.object, name = 'assays')))) {
stop('assay \"', assay, '\" cannot be found in any slots of Seurat object.')
}
# 'ref.path' or 'lr.ref' check
if (is.null(ref.path) && is.null(lr.ref)) {
stop(strwrap('Must provide either \"ref.path\" (path of LR reference) or
\"lr.ref\" (data.frame of imported LR reference).', prefix = ' '))
}
# Load reference csv.
if (!is.null(lr.ref)) {
lr_ref <- lr.ref
}
if(!is.null(ref.path)) {
lr_ref <- read.csv(file = ref.path, stringsAsFactors = FALSE)
}
# Check for Pair.Name column. Error if not present.
if (!any(colnames(lr_ref) == 'Pair.Name')) {
stop(strwrap('Ligand-receptor reference list requires a column titled
\"Pair.Name\". Entries in \"Pair.Name\" should be formatted as: [Ligand
gene]_[Receptor gene]. E.g. Apoe_Lrp1"', prefix = ' '))
} else {
message('LR reference has ', nrow(lr_ref), ' rows (LR pairs).')
}
# Message regarding use of seurat identities
active_idents <- as.character(x = slot(
object = seurat.object,
name = 'active.ident'
))
if (any(grepl(' |\\.|\\*|\\&', x = unique(active_idents)))) {
stop(strwrap('Active identities contain special characters (such as
spaces). Replace with "_".', prefix = ' '))
}
tmp_idents <- paste(unique(active_idents), collapse = ', ')
message(paste0('Using active identities: ', tmp_idents))
rm(tmp_idents)
# Split Pair.Name into ligand and receptor names. Retain those that are
# present in the expression data.
all_genes <- rownames(slot(object = seurat.object[[assay]], name = 'data'))
lr_ref <- lr_ref[!duplicated(lr_ref[['Pair.Name']]),]
tmp <- strsplit(x = lr_ref[['Pair.Name']], split = '_')
ligand_genes <- sapply(X = tmp, FUN = `[`, 1)
receptor_genes <- sapply(X = tmp, FUN = `[`, 2)
ligand_present <- ligand_genes %in% all_genes
receptor_present <- receptor_genes %in% all_genes
lr_ref <- lr_ref[ligand_present & receptor_present, ]
if (nrow(lr_ref) == 0) {
stop('No LR pairs were detected in provided Seurat data.')
} else {
ligand_genes <- ligand_genes[ligand_present & receptor_present]
receptor_genes <- receptor_genes[ligand_present & receptor_present]
message('Genes detected for ', nrow(lr_ref), ' LR pairs')
}
rm(tmp, ligand_present, receptor_present, all_genes)
# Extract data. Convert factor-type column variables to character-type.
Seurat::DefaultAssay(seurat.object) <- assay
lr_data <- Seurat::FetchData(
object = seurat.object,
vars = unique(c(split.by, ligand_genes, receptor_genes)),
slot = slot
)
is_factor <- which(sapply(X = lr_data, FUN = class) == 'factor')
lr_data[is_factor] <- lapply(
X = lr_data[is_factor],
FUN = as.character
)
lr_data <- cbind(active_idents, lr_data)
message('Using expression values for ', ncol(lr_data)-1, ' genes across ',
nrow(lr_data), ' cells.')
rm(active_idents)
# Calculate average/percent expression for each gene, by "split.by" if
# provided.
exp_avg <- lr_data %>%
group_by(active_idents, .add = TRUE)
exp_pct <- lr_data %>%
group_by(active_idents, .add = TRUE)
if (!is.null(split.by)) {
split.by_name <- as.name(split.by)
exp_avg <- exp_avg %>%
group_by(!!split.by_name, .add = TRUE)
exp_pct <- exp_pct %>%
group_by(!!split.by_name, .add = TRUE)
}
exp_avg <- exp_avg %>%
summarise(
across(.cols = where(is.numeric),
.fns = mean
)
)
exp_pct <- exp_pct %>%
summarise(
across(.cols = where(is.numeric),
.fns = function(x) round(mean(x > 0), 3)
)
)
# Determine which genes meet minimum percent detection threshold
minpct_genes <- sapply(
FUN = function(x, min.pct) {any(x > min.pct)},
X = exp_pct[sapply(exp_pct, is.numeric)],
min.pct = min.pct
)
minpct_genes <- names(which(minpct_genes))
ligand_detected <- ligand_genes %in% minpct_genes
receptor_detected <- receptor_genes %in% minpct_genes
ligand_genes <- ligand_genes[ligand_detected & receptor_detected]
receptor_genes <- receptor_genes[ligand_detected & receptor_detected]
lr_ref <- lr_ref[ligand_detected & receptor_detected,]
rm(minpct_genes)
# Generate all possible combinations of cell-type pairs (and split.by). Create
# columns with cell-type counts for permutation test sampling.
if (!is.null(split.by)) {
var_set <- expand.grid(unique(lr_data[['active_idents']]),
unique(lr_data[['active_idents']]),
unique(lr_data[[split.by]]),
stringsAsFactors = FALSE)
colnames(var_set) <- c('Ligand_cell', 'Receptor_cell', 'split.by')
cell_counts <- table(
slot(object = seurat.object, name = 'active.ident'),
slot(object = seurat.object, name = 'meta.data')[[split.by]]
)
} else {
var_set <- expand.grid(unique(lr_data[['active_idents']]),
unique(lr_data[['active_idents']]),
stringsAsFactors = FALSE)
colnames(var_set) <- c('Ligand_cell', 'Receptor_cell')
cell_counts <- table(slot(object = seurat.object, name = 'active.ident'))
}
var_set$Ligand_cell_count <- NA
var_set$Receptor_cell_count <- NA
for (i in 1:nrow(var_set)) {
tmp_row_lig <- which(rownames(cell_counts) == var_set$Ligand_cell[i])
tmp_row_rec <- which(rownames(cell_counts) == var_set$Receptor_cell[i])
tmp_col <- which(colnames(cell_counts) == var_set$split.by[i])
var_set$Ligand_cell_count[i] <- cell_counts[tmp_row_lig, tmp_col]
var_set$Receptor_cell_count[i] <- cell_counts[tmp_row_rec, tmp_col]
}
rm(tmp_row_lig, tmp_row_rec, tmp_col)
# Calculate LR scores (for data, not nulls). Convert to list to vectorize.
index_x <- var_set[['Ligand_cell']]
index_y <- var_set[['Receptor_cell']]
exp_names <- exp_avg[['active_idents']]
if (!is.null(split.by)) {
index_x <- paste(index_x, var_set[['split.by']], sep = '_')
index_y <- paste(index_y, var_set[['split.by']], sep = '_')
exp_names <- paste(exp_names, exp_avg[[split.by]], sep = '_')
}
index_x <- match(x = index_x, table = exp_names)
index_y <- match(x = index_y, table = exp_names)
index_l <- match(ligand_genes, colnames(exp_avg))
index_r <- match(receptor_genes, colnames(exp_avg))
exp_avg_lig <- as.matrix(exp_avg[index_x, index_l])
exp_avg_rec <- as.matrix(exp_avg[index_y, index_r])
exp_scores <- 1/2 * (exp_avg_lig + exp_avg_rec)
exp_scores <- split(
x = exp_scores,
f = rep(1:nrow(exp_scores), each = ncol(exp_scores))
)
names(exp_scores) <- apply(
X = var_set,
MARGIN = 1,
FUN = function(x) {
if (!is.null(split.by)) {
paste(x[c('Ligand_cell','Receptor_cell','split.by')], collapse = '_')
} else {
paste(x[c('Ligand_cell','Receptor_cell')], collapse = '_')
}
}
)
exp_scores <- lapply(
X = exp_scores,
FUN = function(x) {
names(x) <- paste(colnames(exp_avg_lig),
colnames(exp_avg_rec),
sep = '_')
return(x)
}
)
# Extract individual matrices for ligand/receptor gene expression values to be
# used for random sampling of cells (via matrix multiplication). Reformat the
# lr_data data.frame to data.table before setting matrix to allow duplicated
# column names (gene names)
lr_data_ligands <- as.matrix(as.data.table(lr_data)[, ..ligand_genes])
lr_data_receptors <- as.matrix(as.data.table(lr_data)[, ..receptor_genes])
CalculateScorePvals(
exp.scores = exp_scores[[1]],
total.count = nrow(lr_data),
resample = 1000,
lr.data.ligands = lr_data_ligands,
lr.data.receptors = lr_data_receptors,
l.count = var_set$Ligand_cell_count[1],
r.count = var_set$Receptor_cell_count[1]
)
mapply(
FUN = CalculateScorePvals,
exp.scores = exp_scores,
l.count = var_set$Ligand_cell_count,
r.count = var_set$Receptor_cell_count,
MoreArgs = list(
total.count = nrow(lr_data),
resample = resample,
lr.data.ligands = lr_data_ligands,
lr.data.receptors = lr_data_receptors,
)
)
mapply(
FUN = CalculateScorePvals,
exp.scores = exp_scores,
l.count = var_set$Ligand_cell_count,
r.count = var_set$Receptor_cell_count,
MoreArgs = list(
total.count = nrow(lr_data),
resample = resample,
lr.data.ligands = lr_data_ligands,
lr.data.receptors = lr_data_receptors
)
''
source('D:/SingleCellTools/R/StandardLR2.R', echo=TRUE)
rm(list = ls())
gc()
dev.off()
require('Seurat')
require('dplyr')
require('tibble')
require('data.table')
vascular <- readRDS(file = '../MiamiProject/sci_scRNAseq/data/vascular.rds')
vascular$vascular_subcluster <- gsub(
pattern = ' ',
replacement = '-',
x = vascular$vascular_subcluster
)
Idents(vascular) <- 'vascular_subcluster'
ref <- read.csv(file = '../MiamiProject/sci_scRNAseq/ref/fantom_PairsLigRec_mouse.csv')
ref <- ref[1:50,]
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
source('D:/SingleCellTools/R/StandardLR2.R', echo=TRUE)
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
require('BiocParallel')
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
source('D:/SingleCellTools/R/StandardLR2.R', echo=TRUE)
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
source('D:/SingleCellTools/R/StandardLR2.R', echo=TRUE)
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 2, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
t3
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 4, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
t3
t3 <- Sys.time()
test3 <- StandardLR2(
seurat.object = vascular,
lr.ref = ref,
split.by = 'time',
BPPARAM = SnowParam(workers = 4, type = 'SOCK', exportglobals = FALSE)
)
t3 <- Sys.time() - t3 # 2.6 min
t3
8.2*60
2.6*60
getwd()
devtools::install('SingleCellTools', args = c("--no-multiarch"))
rm(list = ls())
gc()
dev.off()
